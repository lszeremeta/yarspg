<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>YARS-PG 4.0</title>
    <script async class='remove' src='https://www.w3.org/Tools/respec/respec-w3c'></script>
    <script class='remove'>
        var respecConfig = {
            specStatus: "unofficial",
            editors: [
                {
                    name: "Łukasz Szeremeta",
                    company: "University of Bialystok",
                    companyURL: "http://uwb.edu.pl",
                    mailto: "l.szeremeta@uwb.edu.pl",
                },
                {
                    name: "Dominik Tomaszuk",
                    company: "University of Bialystok",
                    companyURL: "http://uwb.edu.pl",
                    mailto: "d.tomaszuk@uwb.edu.pl",
                },
                {
                    name: "Renzo Angles",
                    company: "Universidad de Talca and Fundational Reasearch on Data",
                    companyURL: "https://www.utalca.cl",
                    mailto: "rangles@utalca.cl",
                }],
            github: {
                repoURL: "https://github.com/lszeremeta/yarspg",
                branch: "master",
            },
            shortName: "yarspg",
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>
            The YARS-PG serialization was designed to be simple, extensible and platform independent, and to support all
            the
            features provided by the current database systems based on the property graph data model.
        </p>
    </section>
    <section id='sotd'>
        <p>
            This is very early draft of YARS-PG specification based on YARS-PG 4.0.
        </p>
    </section>
    <section id='introduction' class="informative">
        <h2>Introduction</h2>
        <p>This document defines YARS-PG, a serialization for property graphs.</p>
        <aside class="example" title="Bibliographic information">
            <p>The example presents a graphical representation of a property graph that contains bibliographic
                information.
                <pre>
# Prefix declaration
:foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

# Metadata
-foaf:maker: "Łukasz Szeremeta and Dominik Tomaszuk"

# Node schema
S{"Author"}["fname": String, "lname": String]
S{"Entry", "InProc"}["title": String, "numpages": Integer, "keyword": String]
S{"Entry", "Article"}["title": String, "numpages": Integer, "keyword": List(String)]
S{"Proceedings"}["title": String, "year": Integer, "month": String]
S{"Journal"}["title": String, "year": Integer, "vol": Integer]

# Nodes
<"Author01">{"Author"}["fname": "John", "lname": "Smith"] #Author01
<"Author02">{"Author"}["fname": "Alice", "lname": "Brown"]
<"EI01">{"Entry", "InProc"}["title": "Serialization for...", "numpages": 10, "keyword": "Graph database"]
<"EA01">{"Entry", "Article"}["title": "Property Graph...",  "numpages": 10, "keyword": ["Query", "Graph"]]
<"Proc01">{"Proceedings"}["title": "BDAS", "year": 2018, "month": "May"]
<"Jour01">{"Journal"}["title": "J. DB", "year": 2020, "vol": 30]

# Edge schema
S("Entry")-{"has_author"}["order": Integer]->("Author")
S("Entry")-{"cities"}->("Entry")
S("InProc")-{"booktitle"}["pages": String]->("Proceedings")
S("Article")-{"published_in"}["pages": String]->("Journal")

# Edge
("EI01")-{"has_author"}["order": 1]->("Author01")
("EI01")-{"has_author"}["order": 2]->("Author02")
("EA01")-{"has_author"}["order": 1]->("Author02")
("EA01")-{"cites"}->("EI01")
("EI01")-{"booktitle"}["pages": "111-121"]->("Proc01")
("EA01")-{"published_in"}["pages": "222-232"]->("Jour01")
  </pre>
        </aside>
        <p>The YARS-PG serialization supports all the features allowed by the current database systems based on the
            property
            graph data model, and can be adapted to work with various visualization software, database-driven systems
            and
            other graph-oriented tools.</p>
    </section>
    <section id='yarspg-language'>
        <h2>YARS-PG Language</h2>
        The YARS-PG serialization contains node declarations and edge declaration (no order is required for them).
        <section id='comment'>
            <h2>Comment</h2>
            <p>An one-line <dfn>comment</dfn> allows to place additional information in the file that is not taken into
                account during its processing.</p>
            <aside class="example" title="Comments">
                <p>The example presents two one-line comments.
                    <pre>
# TODO: Check this later
# ABD5 schema
      </pre>
            </aside>
        </section>
        <section id='prefix'>
            <h2>Prefix</h2>
            <p>A <dfn>prefix declaration</dfn> associates a prefix label with an IRI.</p>
            <aside class="example" title="Prefix declaration">
                <p>The example presents prefix declaration for <code>foaf</code>.
                    <pre>
:foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  </pre>
            </aside>
        </section>
        <section id='metadata'>
            <h2>Metadata</h2>
            <p>A <dfn>metadata declaration</dfn> represents a collection of metadata for the document.</p>
            <aside class="example" title="Metadata declaration">
                <p>The example presents metadata declaration with <code>foaf</code> prefix and the same metadata declaration with full IRI below.
                    <pre>
-foaf:maker: "Łukasz Szeremeta and Dominik Tomaszuk"
-&lt;http://xmlns.com/foaf/0.1/maker&gt;: "Łukasz Szeremeta and Dominik Tomaszuk"
  </pre>
            </aside>
        </section>
        <section id='node'>
            <h2>Node</h2>
            <p>A <dfn>node declaration</dfn> begins with the node identifier, followed by a list of node labels and
                optional
                properties of the node.</p>
            <aside class="example" title="Node declaration">
                <p>The example presents node declaration for node <code>EI01</code>. This node have two labels
                    (<code>Entry</code> and <code>InProc</code>)
                    and three properties (<code>title</code>, <code>numpages</code> and <code>keyword</code>).
                    <pre>
<"EI01">{"Entry", "InProc"}["title": "Serialization for...", "numpages": 10, "keyword": "Graph database"]
  </pre>
            </aside>
        </section>
        <section id='edge'>
            <h2>Edge</h2>
            <p>A <dfn>relationship declaration</dfn> begins with the source node identifier, followed by relationship
                identifier
                (optional), a label, a set of properties (optional) and target node identifier. Relationships can be
                directed (<code>-></code>) or undirected (<code>-</code>).</p>
            <aside class="example" title='Edge declaration'>
                <p>The example presents edge declaration from source node <code>EI01</code> to target node
                    <code>Author01</code>. Relationship
                    have label <code>has_author</code> and one property (<code>order</code>).
                    <pre>
("EI01")-{"has_author"}["order":1]->("Author01")
  </pre>
            </aside>
        </section>
        <section id='property'>
            <h2>Property</h2>
            A <dfn>property</dfn> is represented as a pair <code>p:v</code>, where <code>p</code> is the property label
            and <code>v</code> the property value. A
            property value could be atomic (e.g. String, Integer, Float, Null, Boolean) or complex (e.g. a list of
            atomic values).</p>

            <aside class="example" title="Edge declaration with Timestamp property value">
                <p>The example presents edge declaration with <code>Timestamp</code> property value.</p>
                <pre>
("ABC5")-{"label5"}["timestamp": 1999-01-01T11:15:32]->("XYZ5")
  </pre>

        </section>
        <section id='annotation'>
            <h2>Annotation</h2>
            An <dfn>annotation</dfn> is represented as a pair <code>k:v</code>, where <code>k</code> is the key (that
            can be a string, QName or IRI) and <code>v</code> the value of attribute.</p>
            <aside class="example" title="Annotation declaration">
                <p>The example presents three variants of node declaration with annotation. The first one contains an RDF annotation with prefix, the second one contains an RDF annotation with IRI and the third one contains a string annotation.</p>
                <pre>
    <"b43b">{"label1"}["value":5]+foaf:maker: "Łukasz Szeremeta and Dominik Tomaszuk"
    <"b43b">{"label1"}["value":5]+&lt;http://xmlns.com/foaf/0.1/maker&gt;: "Łukasz Szeremeta and Dominik Tomaszuk"
    <"b43b">{"label1"}["value":5]+"maker": "Łukasz Szeremeta and Dominik Tomaszuk"
    </pre>
            </aside>
        </section>
        <section id='namedgraph' class="informative">
            <h2>Named Property Graph</h2>
            <p>A <dfn>Named Property Graph declaration</dfn> is represented as a list of graphs names.</p>
            <p>Graph names can be added to node, edge and node schema declarations.</p>
            <aside class="example" title="Named Property Graphs declaration">
                <p>The example presents node declaration with property graph names (<code>graph1</code> and
                    <code>graph2</code>).</p>
                <pre>
<"z">{"432f"}["vegetables": ["carrot", "onion", "tomato"]]/"graph1", "graph2"/
</pre>
            </aside>
        </section>
    </section>
    <section id='yarspg-schema-language'>
        <h2>YARS-PG Schema Language</h2>
        <p>An <dfn>YARS-PG schemas</dfn> may be used to determine the expected structure of a YARS-PG document.</p>
        <section id='snodes'>
            <h2>Nodes</h2>
            <p>A <dfn>node schema declaration</dfn> begins with list of node labels, followed by optional properties of
                the node.</p>
            <aside class="example" title="Node schema declaration">
                <p>The example presents node schema declaration.</p>
                <pre>
S{"Author"}["fname": String, "lname": String]
S{"Entry", "InProc"}["title": String, "numpages": Integer, "keyword": String]
S{"Entry", "Article"}["title": String, "numpages": Integer, "keyword": List(String)]
S{"Proceedings"}["title": String, "year": Integer, "month": String]
S{"Journal"}["title": String, "year": Integer, "vol": Integer]
  </pre>
            </aside>
        </section>
        <section id='sedges'>
            <h2>Edges</h2>
            <p>A <dfn>relationship schema declaration</dfn> begins with the node label, followed by a label,
                a set of properties (optional) and target node identifier. Relationships schema can be
                directed (<code>-></code>) or undirected (<code>-</code>).</p>
            <aside class="example" title="Edge schema declaration">
                <p>The example presents edge schema declaration.</p>
                <pre>
S("Entry")-{"has_author"}["order": Integer]->("Author")
S("Entry")-{"cities"}->("Entry")
S("InProc")-{"booktitle"}["pages": String]->("Proceedings")
S("Article")-{"published_in"}["pages": String]->("Journal")
  </pre>
            </aside>
        </section>
        <section id='datatypes'>
            <h2>Datatypes</h2>
            <p>YARS-PG supports several primitive and complex <dfn>datatypes</dfn> including <code>String</code>,
                <code>Integer</code>, <code>Date</code> and <code>List</code>. Datatypes can be used to declare the type
                of expected value in schemas.</p>
            <section id='pdatatype'>
                <h3>Primitive datatypes</h3>
                <p>The following <dfn>primitive datatypes</dfn> are supported:
                    <code>Decimal</code>, <code>SmallInt</code>, <code>Integer</code>, <code>BigInt</code>,
                    <code>Float</code>, <code>Real</code>, <code>Double</code>, <code>Bool</code>, <code>Null</code>,
                    <code>String</code>, <code>Date</code>, <code>Time</code> and <code>Timestamp</code>.</p>

                <aside class="example" title="Bool and null properties in the edge schema and edge declaration">
                    <p>The example presents edge schema and edge declarations with <code>Bool</code> and
                        <code>Null</code> properties.</p>
                    <pre>
S("label1")-{"bbb23b"}["bbbd32d": Bool, "value": Null]-("ef22")
("b43b")-{"bbbb53b"}["bbbd32d": false, "value": null]-("e")
              </pre>
                </aside>

                <aside class="example" title="Timestamp property with timezone in the edge schema and edge declaration">
                    <p>The example presents edge schema and edge declarations with <code>Timezone</code> property.</p>
                    <pre>
S("A6")-{"label6"}["timestamptzp": Timestamp]->("Z6")
("ABC6")-{"label6"}["timestamptzp": 1999-01-01T11:15:32+01:30]->("XYZ6")
              </pre>
                </aside>
            </section>
            <section id='cdatatype'>
                <h3>Complex datatypes</h3>
                <p>The following <dfn>complex datatypes</dfn> are supported:
                    <code>Set</code>, <code>List</code> and <code>Struct</code>.</p>
                <p><code>Set</code> disallows duplicate elements. <code>List</code> allows duplicate elements, provided
                    the order of retrieval is not significant. <code>Struct</code> is a collection of name/value pairs.
                </p>

                <aside class="example" title="Set property in the node schema and node declaration">
                    <p>The example presents node schema and node declarations with <code>Set</code> property that
                        contains <code>String</code> elements.</p>
                    <pre>
S{"432f"}["fruits": Set(String)]/"fgraph"/
<"z">{"432f"}["fruits": {"apple", "banana"}]/"fgraph"/
          </pre>
                </aside>

                <aside class="example" title="Struct property in the node schema and node declaration">
                    <p>The example presents node schema and node declarations with <code>Struct</code> property that
                        contains another <code>Struct</code> with <code>String</code> elements.</p>
                    <pre>
S{"2label4"}["keyword2": Struct(Struct(String))]
<"2i44">{"2label4"}["keyword2": {"names": {"name": "abc", "title": "xyz"}, "names2": {"name2": "abc2", "title2": "xyz2"}, "names3": {"name3": "abc3", "title3": "xyz3"}}]
              </pre>
                </aside>

            </section>
        </section>
    </section>
    <section id='canonical-form'>
        <h2>Canonical form</h2>
        <p>A <dfn>canonical version of YARS-PG</dfn> must meet the list of conditions specified below.</p>
        <ul>
            <li>Cannot contain:
                <ul>
                    <li>comments,</li>
                    <li>empty lines with only LF or CR,</li>
                    <li>whitespaces (spaces <code>U+0020</code> or tabs <code>U+0009</code>) between serialization elements (e.g. excluding <code>String</code> value),</li>
                    <li>prefix declarations and prefixed version of IRI.</li>
                </ul>
            </li>
            <li>each declaration must be definied on one line only (no multi-line declarations),</li>
            <li>document must be divided into sections with section declarations.</li>
        </ul>

        <aside class="example" title="Bibliographic information - canonical form">
            <p>The example presents a graphical representation of a property graph that contains bibliographic
                information in canonical form
                <pre>
%METADATA
-&lt;http://xmlns.com/foaf/0.1/maker&gt;:"Łukasz Szeremeta and Dominik Tomaszuk"
%NODE SCHEMAS
S{"Author"}["fname":String,"lname":String]
S{"Entry","InProc"}["title":String,"numpages":Integer,"keyword":String]
S{"Entry","Article"}["title":String,"numpages":Integer,"keyword":List(String)]
S{"Proceedings"}["title":String,"year":Integer,"month":String]
S{"Journal"}["title":String,"year":Integer,"vol":Integer]
%EDGE SCHEMAS
S("Entry")-{"has_author"}["order":Integer]->("Author")
S("Entry")-{"cities"}->("Entry")
S("InProc")-{"booktitle"}["pages":String]->("Proceedings")
S("Article")-{"published_in"}["pages":String]->("Journal")
%NODES
<"Author01">{"Author"}["fname":"John","lname":"Smith"]#Author01
<"Author02">{"Author"}["fname":"Alice","lname":"Brown"]
<"EI01">{"Entry","InProc"}["title":"Serialization for...","numpages":10,"keyword":"Graph database"]
<"EA01">{"Entry","Article"}["title":"Property Graph...","numpages":10,"keyword":["Query","Graph"]]
<"Proc01">{"Proceedings"}["title":"BDAS","year":2018,"month":"May"]
<"Jour01">{"Journal"}["title":"J. DB","year":2020,"vol":30]
%EDGES
("EI01")-{"has_author"}["order":1]->("Author01")
("EI01")-{"has_author"}["order":2]->("Author02")
("EA01")-{"has_author"}["order":1]->("Author02")
("EA01")-{"cites"}->("EI01")
("EI01")-{"booktitle"}["pages":"111-121"]->("Proc01")
("EA01")-{"published_in"}["pages":"222-232"]->("Jour01")
          </pre>
        </aside>

        <section id='section'>
            <h2>Section declaration</h2>
            <p>A <dfn>section declaration</dfn> represents a name of the section of the YARS-PG document.</p>
            <p>The following sections are distinguished: <code>METADATA</code>,
                <code>NODE SCHEMAS</code>, <code>NODES</code>, <code>EDGE SCHEMAS</code> and <code>EDGES</code>.</p>
            <aside class="example" title="Section declaration">
                <p>The example presents <code>METADATA</code> section declarations with metadata declaration.
                    <pre>
        %METADATA
        -&lt;http://xmlns.com/foaf/0.1/maker&gt;:"Łukasz Szeremeta and Dominik Tomaszuk"
              </pre>
            </aside>
        </section>

        <section id='canonicalization'>
            <h2>Canonicalization</h2>
            <p>The following algorithm can be used to convert YARS-PG into a canonical form:</p>
            <ol class="algorithm">
                <li>Remove all comments</li>
                <li>Transform prefixes into full IRIs</li>
                <li>Remove prefix declarations</li>
                <li>Roll up multi-line declarations into one line declarations</li>
                <li>Reorder declarations for sections in that order: metadata, node schemas, edge schemas, nodes, edges</li>
                <li>Add section declaration for each section</li>
                <li>Remove all empty lines with only LF or CR</li>
                <li>Remove all whitespaces (spaces <code>U+0020</code> or tabs <code>U+0009</code>) between serialization elements</li>
            </ol>
        </section>
    </section>

    <section id='yarspg-grammar'>
        <h2>YARS-PG Grammar</h2>
        <p>The grammar of YARS-PG is written in [[ANTLR4]]. We have also prepared a preview of the grammar in
            [[EBNF-NOTATION]].
        </p>

            <p>A preview version of YARS-PG grammar in [[EBNF-NOTATION]] is presented below.</p>
            <pre>
yarspg   ::= statement+
statement
         ::= node
           | edge
           | prefix_directive
           | metadata
           | node_schema
           | edge_schema
           | section
prefix_directive
         ::= pname IRI
pname    ::= ':' ALNUM_PLUS ':'
pn_local ::= ALNUM_PLUS
metadata ::= '-' ( pn_local pname STRING | IRI ':' ( STRING | IRI ) )
annotation
         ::= string_annotation
           | rdf_annotation
string_annotation
         ::= STRING ':' STRING
rdf_annotation
         ::= ( pn_local pname | IRI ':' ) ( STRING | IRI )
annotations_list
         ::= '+' annotation ( ',' annotation )+
props_list
         ::= '[' prop ( ',' prop )+ ']'
graphs_list
         ::= '/' graph_name ( ',' graph_name )+ '/'
node
         ::= '<' node_id '>' ( '{' node_label ( ',' node_label )+ '}' )? props_list? graphs_list? annotations_list?
edge
         ::= directed
           | undirected
section  ::= '%' SECTION_NAME           
directed ::= '(' node_id ')' '-' ('<' edge_id '>')? '{' edge_label '}' props_list? '->' '(' node_id ')' graphs_list? annotations_list?
undirected
         ::= '(' node_id ')' '-' ('<' edge_id '>')? '{' edge_label '}' props_list? '-' '(' node_id ')' graphs_list? annotations_list?
node_id  ::= STRING
node_label
         ::= STRING
prop
         ::= key ':' value         
edge_id   ::= STRING
edge_label
         ::= STRING
key      ::= STRING
value    ::= primitive_value
           | complex_value
primitive_value
         ::= STRING
           | NUMBER
           | DATETYPE
           | BOOL
           | 'null'
complex_value
         ::= set
           | list
           | struct
set ::= '{' ( primitive_value | set ) ( ',' ( primitive_value | set ) )* '}'
list     ::= '[' ( primitive_value | list ) ( ',' ( primitive_value | list ) )* ']'
struct     ::= '{' key ':' ( primitive_value | struct ) ( ',' key ':' ( primitive_value | struct ) )* '}'
node_schema
         ::= 'S' ( '{' node_label ( ',' node_label )+ '}' )? props_list_schema? graphs_list? annotations_list?
props_list_schema
         ::= '[' prop_schema ( ',' prop_schema )+ ']'
prop_schema
         ::= key ':' value_schema
value_schema
         ::= primitive_value_schema
           | complex_value_schema
primitive_value_schema
         ::= 'Decimal'
           | 'SmallInt'
           | 'Integer'
           | 'BigInt'
           | 'Float'
           | 'Real'
           | 'Double'
           | 'Bool'
           | 'Null'
           | 'String'
           | 'Date'
           | 'Time'
           | 'Timestamp'
complex_value_schema
         ::= set_schema
           | list_schema
           | struct_schema
set_schema
         ::= 'Set' '(' ( primitive_value_schema | set_schema ) ')'
list_schema
         ::= 'List' '(' ( primitive_value_schema | list_schema ) ')'
struct_schema
         ::= 'Struct' '(' ( primitive_value_schema | struct_schema ) ')'
edge_schema
         ::= directed_schema
           | undirected_schema
directed_schema
         ::= 'S' ( '(' node_label ')' )? '-' '{' edge_label '}' props_list_schema? '->' ( '(' node_label ')' )?
undirected_schema
         ::= 'S' ( '(' node_label ')' )? '-' '{' edge_label '}' props_list_schema? '-' ( '(' node_label ')' )?

SECTION_NAME
         ::= 'METADATA'
           | 'NODE SCHEMAS'
           | 'EDGE SCHEMAS'
           | 'NODES'
           | 'EDGES'
COMMENT  ::= '#' [^#xd#xa#xc]*
STRING   ::= STRING_LITERAL_QUOTE
NUMBER   ::= SIGN? [0-9]+ '.'? [0-9]*
BOOL     ::= 'true'
           | 'false'
STRING_LITERAL_QUOTE
         ::= '"' ( [^"\#xd#xa] | "'" | '\"' )* '"'
ALNUM_PLUS
         ::= PN_CHARS_BASE ( ( PN_CHARS | '.' )* PN_CHARS )?
IRI  ::= '<' ( PN_CHARS | '.' | ':' | '/' | '\' | '#' | '@' | '%' | '&' | UCHAR )* '>'
PN_CHARS ::= PN_CHARS_U
           | [-0-9#xB7#x0300-#x036F#x203F-#x2040]
PN_CHARS_U
         ::= PN_CHARS_BASE
           | '_'
DATETYPE ::= DATE
           | TIME
           | TIMESTAMP
DATE     ::= [0-9] [0-9] [0-9] [0-9] '-' [0-9] [0-9] '-' [0-9] [0-9]
TIME     ::= [0-9] [0-9] ':' [0-9] [0-9] ':' [0-9] [0-9] TIMEZONE?
TIMEZONE ::= SIGN? [0-9] [0-9] ':' [0-9] [0-9]
TIMESTAMP
         ::= DATE 'T' TIME
SIGN     ::= '+'
           | '-'
UCHAR    ::= ( '\u' | '\U' HEX HEX HEX HEX ) HEX HEX HEX HEX
PN_CHARS_BASE
         ::= [A-Za-z0-9#xC0-#xD6#xD8-#xF6#xF8-#x2FF#x370-#x37D#x37F-#x1FFF#x200C-#x200D#x2070-#x218F#x2C00-#x2FEF#x3001-#xD7FF#xF900-#xFDCF#xFDF0-#xFFFD]
HEX      ::= [0-9A-Fa-f]
WS       ::= [ #x9#xa]+
    </pre>
    </section>
    <section class="informative" id='parsers'>
        <h2>Parsers</h2>
        <p>Parsers for different languages for the current grammar version will be presented later.</p>
    </section>
</body>

</html>